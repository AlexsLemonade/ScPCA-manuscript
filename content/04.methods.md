## Materials and Methods

### Data generation and processing

Raw data was generated, and sample metadata was compiled by each lab and institution contributing to the Portal.
Single-cell or single-nuclei libraries were generated using one of the commercially available kits from 10X Genomics.
For bulk RNA-seq, RNA was collected and sequenced using either paired-end or single-end sequencing. 
For spatial transcriptomics, cDNA libraries were generated using the Visium kit from 10X Genomics.
All libraries were processed using our open-source pipeline, `scpca-nf`, to produce summarized gene expression data. 

### Processing single-cell and single-nuclei RNA-seq data with alevin-fry
  
To quantify each single-cell and single-nuclei RNA-seq gene expression, `scpca-nf` uses `salmon alevin` [@doi:10.1186/s13059-020-02151-8] and `alevin-fry`[@doi:10.1038/s41592-022-01408-3] to generate a gene by cell counts matrix.
Prior to mapping, we generated an index using transcripts from both spliced cDNA and intronic regions, denoted as the `splici` index.
The index was generated from the human genome, GRCh38, Ensembl version 104. 
`salmon alevin` was run using selective alignment to the `splici` index with the `--rad` option to generate a reduced alignment data (RAD) file required for input to `alevin-fry`. 

The RAD file was used as input to the `generate-permit-list` step of `alevin-fry`. 
For 3' libraries, we used the default `--expected-ori fw`, and for 5' libraries, we used `--expected_ori rc`. 
We provided a list of expected barcodes to `generate-permit-list` based on the 10X kit used.
The `collate` step was run using the default parameters with no modifications.
Finally, the `quant` step was run using the `cr-like-em` resolution strategy for feature quantification and UMI de-duplication. 

### Post alevin-fry processing of single-cell and single-nuclei RNA-seq data

The output from running `alevin-fry` includes a gene-by-cell counts matrix, with reads from both spliced and unspliced reads.
This output is read into R to create a `SingleCellExperiment` using the `fishpond::load_fry()` function. 
The resulting `SingleCellExperiment` contains a `counts` assay with a gene-by-cell counts matrix where all spliced and unspliced reads for a given gene are totaled together. 
We also include a `spliced` assay, which includes a gene-by-cell counts matrix for only spliced reads. 
These matrices include all potential cells, including empty droplets, and are provided in the unfiltered objects included in downloads from the Portal.

Potential empty droplets were identified using `DropletUtils::emptyDropsCellRanger()` and those with a FDR of >= 0.01 were removed. 
If a library did not have a sufficient number of droplets and `DropletUtils::emptyDropsCellRanger()` failed, cells with less than 100 UMIs were removed.
Gene expression data for any cells that remain after filtering are provided in the filtered objects. 

In addition to removing empty droplets, `scpca-nf` also removes any cells that are considered low-quality. 
`miQC` was used to calculate the probability of each cell being compromised [@doi:10.1371/journal.pcbi.1009290]. 
Any cells with a likelihood of being compromised greater than 0.75 and less than 200 genes detected were removed from the object. 
The gene expression counts from the remaining cells were log-normalized using the deconvolution method from Lun, Bach, and Marioni [@doi:10.1186/s13059-016-0947-7]. 
`scran::modelGeneVar()` was used to model gene variance from the log-normalized counts and `scran::getTopHVGs` was used to select the top 2000 high-variance genes. 
These were used as input to calculate principal components using `scater::runPCA()`. 
Finally, UMAP embeddings were calculated from the principal components with `scater::runUMAP()`. 
The raw and log-normalized counts, list of 2000 high-variance genes, principal components, and UMAP embeddings are all stored in the processed object. 

### Quantifying gene expression for libraries with CITE-seq or cell hashing

All libraries with antibody-derived tags (ADTs) or hashtag oligonucleotides (HTOs) were mapped to a reference index using `salmon alevin` and quantified using `alevin-fry`.
The reference indices were constructed using the `salmon index` command with the `--feature` option. 
References were custom-built for each ScPCA project and constructed using the submitter-provided list of ADTs or HTOs and their barcode sequences. 

The ADT by cell or HTO by cell counts matrix produced by `alevin-fry` were read into R as a `SingleCellExperiment` object and saved as an `altExp` in the same `SingleCellExperiment` object with the unfiltered gene expression counts data. 
The `altExp` within the unfiltered object contains all identified ADTs or HTOs and all barcodes identified in the RNA-seq gene expression data.
Any barcodes that only appeared in either ADT or HTO data were discarded, and cell barcodes that were only found in the gene expression data (i.e., did not appear in the ADT or HTO data) were assigned zero counts for all ADTs and HTOs.
Any cells removed after filtering empty droplets were also removed from the ADT and HTO counts matrices and stored in the filtered `SingleCellExperiment` object.
### Processing ADT expression data from CITE-seq

The ADT count matrix stored in the unfiltered object was used to calculate an ambient profile with `DropletUtils::ambientProfileEmpty()`. 
This ambient profile was used to calculate quality-control statistics with `DropletUtils::cleanTagCounts()` for all cells remaining after removing empty droplets. 
Any negative or isotype controls are taken into account when calculating QC statistics.
Cells with a high level of ambient contamination or negative/ isotype controls are flagged as having low-quality ADT expression, but we do not remove any cells based on ADT quality from the object.
The filtered and processed objects contain the results from running `DropletUtils::cleanTagCounts()`. 

ADT data is then normalized by calculating median size factors from the ambient profile with `scuttle::computeMedianFactors()`. 
If median-based normalization failed for any reason, ADT counts were log-transformed after adding a pseudocount of 1. 
Normalized counts are only available for any cells that would be retained after ADT filtering, and any cells that would be filtered out with `DropletUtils::cleanTagCounts()` are assigned `NA`. 
The normalized ADT data is available in the `altExp` of the processed object. 


### Processing HTO data from multiplexed libraries

Although we did not perform any demultiplexing of samples within a multiplexed library, we did apply three different demultiplexing methods. 
Results from all three methods are included in the filtered and processed `SingleCellExperiment` objects along with the HTO counts data. 

#### Genetic demultiplexing

If all samples in a multiplexed library were also sequenced using bulk RNA-seq, we performed genetic demultiplexing using genotype data from both bulk RNA-seq and single-cell or single-nuclei RNA-seq[@doi:10.1093/gigascience/giab062]. 
If bulk RNA-seq was not available, no genetic demultiplexing was performed. 

Bulk RNA-seq reads for each sample were mapped to a reference genome using `STAR` [@doi10.1093/bioinformatics/bts635] and multiplexed single-cell or single-nuclei RNA-seq reads were mapped to the same reference genome using `STARsolo`[@doi:10.1101/2021.05.05.442755].
The mapped bulk reads were used to call variants and assign genotypes with `bcftools mpileup`[@doi:10.1093/gigascience/giab008].
`cellsnp-lite` was then used to genotype single-cell data at the identified sites found in the bulk RNA-seq data [@doi:10.1093/bioinformatics/btab358]. 
Finally, `vireo` was used to identify the sample of origin [@doi:10.1093/bioinformatics/btab358]. 

#### HTO demultiplexing

For all multiplexed libraries, we performed demultiplexing using `DropletUtils::hashedDrops()` and `Seurat::HTODemux()`. 
For both methods, we used the default parameters and only performed demultiplexing on the filtered cells present in the filtered object. 
The results from both these methods are available in the filtered and processed objects. 

### Quantification of spatial transcriptomics data
  - Use of space ranger

### Quantification of bulk RNA-seq data
  - Use of salmon

### Cell type annotation
  - Implementation of SingleR and CellAssign
  - Description of metrics used (e.g., what is the delta median and where does the probability come from)

### Generating merged data
  - combining counts data and metadata

### Converting SingleCellExperiment objects to AnnData objects
  - use of zellkonverter

### Code and data availability
